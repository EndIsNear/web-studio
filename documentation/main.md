- [Уеб базирана среда за разработка на интерактивни уеб приложения с графична насоченост](#уеб-базирана-среда-за-разработка-на-интерактивни-уеб-приложения-с-графична-насоченост)
- [Увод](#увод)
- [Речник](#речник)
- [Описание на проблема](#описание-на-проблема)
- [Описание на решението](#описание-на-решението)
  - [Описание на създаденият от потребителя сайт](#описание-на-създаденият-от-потребителя-сайт)
    - [Визуална част](#визуална-част)
- [Редактор на кода](#редактор-на-кода)
  - [Типове на параметрите и нуждата от тях](#типове-на-параметрите-и-нуждата-от-тях)
  - [Поток на кода, поток на данните](#поток-на-кода-поток-на-данните)
  - [Генериране на кода](#генериране-на-кода)
- [Използвани технологии](#използвани-технологии)
  - [Клиентска част](#клиентска-част)
  - [Сървърна част](#сървърна-част)
- [Ръководство за употреба и освновни примери](#ръководство-за-употреба-и-освновни-примери)
  - [Работа с начална страница](#работа-с-начална-страница)
  - [Работа с редактора на код](#работа-с-редактора-на-код)
  - [Основните видове възли-методи в код-графът и техните параметри](#основните-видове-възли-методи-в-код-графът-и-техните-параметри)
    - [Методи за работа с потока (хода) на кода](#методи-за-работа-с-потока-хода-на-кода)
    - [Методи за работа с числа](#методи-за-работа-с-числа)
    - [Методи за работа с масиви](#методи-за-работа-с-масиви)
    - [Методи за рисуване в платно (canvas)](#методи-за-рисуване-в-платно-canvas)
  - [Основни примери](#основни-примери)
    - [1. Samples](#1-samples)
    - [2. Simple game](#2-simple-game)
    - [3. Draw random squares](#3-draw-random-squares)
    - [4. Velocity square](#4-velocity-square)
    - [5. OnClick velocity](#5-onclick-velocity)
    - [6. Particles](#6-particles)
    - [7. 3D Cube](#7-3d-cube)
- [Заключение](#заключение)
- [Източници](#източници)

# Уеб базирана среда за разработка на интерактивни уеб приложения с графична насоченост

# Увод

Проекта представлява уеб сървър който сервира уеб страница предоставяща възможността да се създават други уеб страници без знания по програмиране - чрез визуално програмиране. Разделя се в две основни части - фронт-енд и бек-енд. Те ще си комуникират чрез web socket протокол. Фронт-енд частта ще дава възможността на потребителя да създава нови елементи в резултатната страница чрез подходящ интерфейс - бутони, текст, картинки и т.н.. Също така потребителят ще може да програмира интерактивни събития чрез flow-based-programing (https://en.wikipedia.org/wiki/Flow-based_programming). Този модул ще поддържа основни програмни приоми - създава и четене на променлива, възможност за показване на променливите във резултатния сайт, основни математически и логически операции, цикли (while/for), условна конструкция (if, if-else), таймери, възможност за повикване на част от кода след натискане на бутон (button callbacks) и други. Фронт-ендът ще бъде отговорен да сериализира данните въведени от потребителя и да ги изпрати на сървъра (бек-енд). Там те ще бъдат преобразуват до html, css и Vue.js (https://vuejs.org/) за визуалната част. За програмната част ще се де-сериализира графът от възли и ще бъде транслиран до javascript код. Новополученият сайт ще бъде изпратен обратно до фронтенда и ще бъде показан във финалният му вид на потребителя.


# Речник

- front-end
- back-end
- http/https
- websocket
- canvas
- framework
- json
- iframe
- node - възел, в частност - метод
- boolean
- DOM
- API

# Описание на проблема

- система за порграмиране на графични уеб приложения
- различни употреби
  
# Описание на решението

Целта на поставената задача е да се създаде уеб страница (сайт) който да предоставя способността на потребител без програмни познания да създаде интерактвен сайт. Сайта се разделя на два основни компонента, front-end или клиентска част и back-end или сървърна част. Front-end е частта от кода която се изпълнява в клиентския браузър, тя е отговорна за почти всичко което вижда клиентът. Back-end е частта която се изпълнява от частен сървър. Сървърната част е отговорна, за зареждането на страницата във браузъра на клиента посредством https и за последващото обработване на данните на клиента. След като клиентската част бъде заредена от браузъра на клиента, всяка инстанция от нея установява връзка с web socket протокола, посредством него клиентската част може лесно да изпраща и приема данни от сървърната част без да се налага страницата да се презарежда всеки път. 

Клиентската част се състои от две уеб страници:
- Първата предоставя възможността за контролиране на съдържанието на резултатния уебсайт, както и показва самия резултат в реално време. Текущото решение дава възможност са създаване/изтриване/преместване на бутони, текст и canvas - резултатният прозорец за визуализиране на графични елементи. 
- Втората страница позволява посредством визуално програмиране да се създава логиката зад сайта. Посредством специално пригоден редактор, потребителя може да редактира "кодът" който резултатът ще изпълнява. Тъй като генераторът на код е основната задача в този труд, на нея има отделена цяла глава.

Всяка от двете страници серилизира всички промени по данните в json формат след което чрез web socket връзката ги изпраща до сървъра. Сървъра обработва новите данни и връща резултатът отново през web socket. Тогава резултатният сайт се показва на потребителя (първата уеб страница). При добра интернет връзка това се случва моментално и недоловимо за потребителя. В страницата за редактиране на визуалната част има и предварителен преглед на резултата, той е постигнат с iframe в който е зареден хиперлинкът на резултатния сайт. Ако потребителя избере да прегледа резултатът чрез бутона "View the result", той вижда същия резултат в самостоятелен прозорец.

Основната задача на сървърната част е да приема клиентските промени, да (ре)генерира резултатът и да го върне обратно на клиента. Посредством web socket сървърът получава всички промени в json формат. След това json-ът бива десериализиран и се изграждат необходимите структури от данни. Следва съставянето на резултатния сайт. Освен това сървърната част може да приема команди за зареждане на примери, те изтриват текущия проект и създават изцяло нов според шаблоните, в последната глава ще разгледам основните примери. След получаване на подадените му структури от данни - лист за всичките елементи в уеб страницата и граф за всичките възли в програмния редактор, сървърът ги транслирани до съответно, html и css за визуалната част и javascript за програмната част. В последната стъпка сървърът е отговорен да предостави резултата на браузъра посредством хиперлинк.

## Описание на създаденият от потребителя сайт

Резултатния сайт се разделя в две основни части - визуална и програмна. Отговорностите на визуалната част се свеждат до презентацията на целия продукт пред потребителя - бутони, текст, картинки, различни анимации и други. В този проект тя е минималистична, единствената и цел е да може да поддържа работата с програмната, фокусът на тази работа е върху програмната част. Основната задача на програмната част е да предостави на потребителя набор от инструменти чрез който, въпреки че няма необходимите знания по текстово програмиране, да създаде интерактивни елементи в уеб приложението (програми).

### Визуална част

Визуалната част се разделя в два основни компонента - html и css. Поради ограничените възможности на програмата във визуалната част решението в този аспект е доста просто (добавяне/премахване на бутони, текст и др.).
В site_builder.go файлът може да видим как се генерира резултатния html. За създаването на сайта се използва базов шаблон, той е еднакъв за всеки сайт генерира чрез това приложение.

  ```
  <!DOCTYPE html>
  <html lang="en">

  <head>
      <link rel="stylesheet" href="style.css">
      <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
      <title>Awesome website 2k22</title>
  </head>

  <body>
      <div id="app">
          <!--All elements created by the user are added here-->
      </div>
      <script src="script.js"></script>
  </body>

  </html>
  ```

Той дефинира основните компоненти необходими за създаването на уеб страница. Зарежда стилът, включва в себе си скрипта отговорен за приложението и др. Следващата стъпка е добавянето на всички елементи създадени от потребителя. Както споменахме, сървърът ги е получил по-рано и ги е сериализирал в масив. Те са сериализирани в полиморфна йерархия спрямо типа си и всяка от имплементациите знае как да върне кореспондиращия html таг. Например ако потребителят е добавил текст "Hello world!", то серилизацията ще създаде инстанция на класа HTMLHeader с правилният текст. В последствие когато се създава резултатната страница всички подобни инстанции ще бъдат изпълнени според реда им на деклариране и ще са отговорни за създаването на кореспондиращия html код. В дадения пример кодът генериран от инстанцията на HTMLHeader с текст "Hello world!", ще изглежда ето така `<h1>Hello world!</h1>`. За бутоните кодът е малко по-сложен, ако потребителят е декларирал бутон с име "Click me" и уникален идентификатор "ID", то кодът ще е изглежда ето така `<button v-on:click="ID()">Click me</button>`. Тук при натискане на бутона в резултатния сайт ще се извика функцията ID() от резултатния javascript файл, ако такава съществува. Преди шаблонния html да се изпрати до браузъра на клиента, всички елементи създадени от потребителя се добавят към шаблона на правилното място, спрямо реда им на дефиниране. Последната стъпка е да се добави платното за рисуване, ако то е включено от потребителя в контролния панел. Ако платното е добавено, последния елемент към резултатния html който се добавя е `<canvas id="myCanvas" width="200px" height="200px" style="border:3px solid black;"></canvas>`. Първоначално той е с грешни размери, но това остава невидимо за потребителя, тъй като ако е включена тази опция се добавя специален javascript код който го оразмерява спрямо големината на браузъра. Но за това по-късно. Последната възможност е да се добавя преглед на променливи. Това е специално маркиран текст - `{{EXAMPLE}}`. Чрез тези двойни скоби и благодарение на фреймуърка vue.js в резултатния сайт вместо този текст ще се покаже стойността на променливата с име EXAMPLE, ако такава съществува. За да съществува тя трябва да бъде спомена поне един път в редактора на кода. Ако не съществува, няма да се покаже нищо в резултатния сайт.

Нека разгледаме стилът на страницата (css), в момента той е напълно статичен и потребителя има единствено възможността да го включва или изключва. Спрямо тази опция сървъра генерира необходимия файл или празен файл. Целия стил е предефиниран в специален шаблонен файл.

# Редактор на кода

Всяко приложение е съставено от алгоритъм или алгоритми. Алгоритъм „набор от правила, които точно дефинират някаква поредица от операции“. Това определение обхваща всички компютърни програми, стига те да прекратяват работа след краен брой операции. Тук съставните части са операциите - те трябва да са достатъчно прости действия. Общоприетия и най-разпространен начин за описване на алгоритъм (програмиране) е чрез текст, дори като кажем програмиране всеки си представя точно това - набор от текстови команди. Друг много разпространен метод за описване на алгоритъм са блок схемите. Блок схемите представляват диаграми, които се използват за записване на алгоритми, за да бъдат изпълнени и да се постигне съответен резултат. Състоят се от геометрични фигури, всяка от които има определено значение. В тези фигури се въвеждат данните, с които трябва да работи изпълнителят на алгоритъма. Фигурите се свързани по между си за да могат да опишат хода на алгоритъма.

![flowchart](/documentation/images/flowchart.png)

В решението на проблема в тази дипломна работа се използва приома на блок схемите, като той се разширява. Блок схемите показват само поредица от действия. Доста често програмите се нуждаят и от обработка на данни, изчисляване на различни математически и други изрази. За да може да се описват подобен тип действия, връзки ще бъдат използвани не само за хода на програмата, но и за предаването на резултатните стойности от изразите. В предложеното решение потребителя може да изрази логиката/алгоритъма на приложението чрез визуални елементи - възли в граф и връзки между тях, подобно на блок схема. Всеки възел в графа ще има различна роля, ще отговаря за даден вид операция. Дори нещо повече, тъй като дори и най-простата математическа операция, събиране на числа, има два входни и един изходен параметри, то и възелът в графа, който я описва, ще трябва да има толкова. За това всеки възел, за напред вместо възел ще използвам и понятието метод, съдържа в себе си осен логиката която описва и редица параметри. И връзките между възлите всъщност са връзки между параметрите на методите. Нека разгледаме много прост пример.

![flow_ex1](/documentation/images/num_op.png)

Този пример демонстрира прочитане на променлива и добавяне на единица към нейната стойност. Тук виждаме два възела, един за взимане на стойност от променлива (Read num) и един за събиране на две числа (Operators). Те са свързани чрез връзка за предаване на числа, от четенето на променлива и неговият изходен параметър е създадена връзка към операцията събиране. Така стойността на променливата се използва в операцията събиране. В този пример няма връзки за поток на кода, всичките възли се оценяват само когато резултатът им бъде поискан от други възли. То ако връзката от резултата на събирането (Result) параметъра, не води никъде, няма да бъде генериран никакъв код за тези възли. Т.е. за да се получи какъв и да е код, се започва от поток на кода.

## Типове на параметрите и нуждата от тях

Нека разгледаме как се построяват връзките между възлите, по-точно параметрите на възлите. За улеснение на потребителя параметрите и по-точно кръглата иконка която позволява свързване им е оцветена според типа на параметъра. Има три вида параметри, съответно и връзки между тях:
- Поток на кода (бял цвят) - Това е основния тип връзки, те определят хода на програмата. Ще се спрем на тях след малко.
- Число (червен цвят) - Този тип връзки позволява "транспортирането" на числа между различните възли.
- Булев тип (зелен цвят) - Този тип пренася резултата от логически операции, например сравнение на числа.

Имплементацията на графа забранява връзките между различни по тип параметри, по този начин предпазва потребителя от наивни грешки.

## Поток на кода, поток на данните

Уеб приложенията често са реактивни, т.е. разчитат основно на потребителски вход, за да извършат дадено действие. Първоначалната ми идея не включваше концепция за поток на кода, възнамерявах за всеки бутон или друго стартиращо действие, да имам отделен граф от възли който да се изпълнява. Но след първоначалната имплементация се забеляза огромен проблем в подхода, липсва нещо много важно - няма как да се създават условия и цикли.

![flow_ex1](/documentation/images/codeflow_ex1.png)

Виждаме как условния възел в средата на графиката (If/Else), може да предизвика изпълнението на различен код според това каква е стойността на променливата VAR, прочетена от метода Read num. Ако не разполагахме с концепцията за поток на кода, взаимствана от блок схемите, това би било невъзможно. Когато потока достигне в даден възел от графа който има за входни параметри данни (число или булев тип), в този момент всички данни които захранват този възел трябва да се оценят. Иначе казано потока на кода води до различни методи в графа, а те от своя страна посредством потока на данните, се захранват с необходимата им информация. В горния пример може да видим как според това дали числото е по-голямо от 1024 потока на кода се разклонява. И всяко от разклоненията използва коренно различен поток на данните.

![flow_ex2](/documentation/images/codeflow_ex2.png)
TODO графика 5.5.5.5.5

Ако искаме от един изходен параметър за поток на кода да изпълним две команди има два начина, както се вижда в графиката. Единия е просто да направим две връзки, но той не гарантира наредба, дори ако приложението предлагаше верификация на графа на кода, това би било грешка. Другият е специалният възел в графа Split flow. Неговата единствена цел е от един поток на кода да бъдат създадени два и да е пределно ясно в каква поредност ще бъдат изпълнени те.

## Генериране на кода

По правило когато сървърът оценява графът на кода, той винаги тръгва от всеки един от стартовите методи, например при натискане на бутон (On click) или на определен интервал от време (On timer). Всички възли от този тип имат изходен параметър за поток на кода. Когато те бъдат свързани с друг възел, който от своя страна има зависимост чрез поток на данни, тогава всички параметри, които са свързани, се разглеждат рекурсивно докато не се достигне до възли без входни параметри. След което може да се продължи по потока на кода.

![Code generation img](/documentation/images/code_gen.png)

Нека използвайки горния пример да разгледаме как сървъра би генерирал кода. Когато се генерира кодът за този граф, се започва от стартиращия нод, в случая това е възелът за обработване на натискане на бутон (OnClick). Той ще генерира следният код `ID: function () { DEPENDENCIES_CODE }`, който ще бъде добавен в инстанцията на класа App. На мястото на DEPENDENCIES_CODE ще се добави всичкият код който се извиква от този стартов метод. След това ще се оцени следващият метод по потока на кода, в този случай това е възелът за записване на променлива (Write num). В дадения случай, той ще създаде следния код `WriteNumN1=()=>{ return DEPENDENCIES_CODE } this.VAR=WriteNumN1()`, до тук получения резултат ще изглежда така `ID: function () { f1=()=>{ return DEPENDENCIES_CODE } this.VAR=f1() }`. След това ще се оценят всички входни параметри на записването на променлива, в случая той е един единствен умножение на числа (Operators). Тук генерирания код ще бъде `DEPENDENCIES_CODE * 2`. Следващата стъпка предполага изчисление на всички аргументи на умножението - прочитането на променлива VAR (Read num), тук кода ще е много прост и той ще бъде просто `this.VAR`. След като композираме сегментите, като заместваме DEPENDENCIES_CODE с последващия код, финално ще получим:

```
  ID: function () {
      WriteNumN1 = () => {
          return this.VAR * 2.0;
      };
      this.VAR=WriteNumN1();
  }
```

Това ще бъде и финалният код за примерния граф.


Освен основната задача за генерирането на кода, редактора на код има още две спомагателни задачи. Първата от тях е да се грижи за всички променливи и тяхната инициализация. Това става много просто, по време на оценяване на графа програмата запомня всяка срещната във възлите променлива. След това в генерирания код поставя имената на всички срещнати променливи и превантивно ги инициализира със стойност по подразбиране за дадения тип, например 0 за числа. Ако потребителя е добавил възел от тип OnStart, той също бива използван за инициализиране на променливи. Чрез него потребителя може да задава стойност на променливите различни от тези по подразбиране. Другата спомагателна задача е обработването на грешки при създаване на графа, за жалост на този етап решението не предлага такава верификация. Някои от потенциалните грешки се обработват правилно, но преобладаващата част от тях се игнорира напълно. Например такъв е дадения по-горе пример (графика 5.5.5.5.5) с две изходни връзки от един параметър за поток на кода. Също така потребителят може да създава безкрайни цикли, за което програмата може да го предупреди.

# Използвани технологии

Отново ще разгледаме в две основни категории. Първата е front end или клиентска част, а другата е back-end или сървърна част.

## Клиентска част

Както и редактора на сайта, така и резултатния сайт са динамични уеб приложения и се отварят посредством браузер. Поради това най-логичният избор е за тях да се използва стандартния уеб стек - html, css и javascript. Те се занимават със създаването, поддържането, оформлението, навигацията и функционалността на интернет страниците. Използването на тези технологии позволява приложението да се отваря на всякакви устройства, които имат уеб браузър - компютри, лаптопи, смартфони, таблети, телевизори и други.
- HTML - основният маркиращ език за описание и дизайн на уеб страници. HTML е стандарт в интернет, а правилата се определят от международния консорциум W3C. Текущата версия на стандарта е HTML 5.0. Описанието на документа става чрез специални елементи, наречени HTML елементи или маркери, които се състоят от етикети или тагове (HTML tags) и ъглови скоби (например елемента <html>). HTML елементите са основната градивна единица на уеб страниците. Чрез тях се оформят отделните части от текста на една уеб страница, като заглавия, цитати, раздели, хипертекстови препратки и т.н.

  ```
  <html>
    <body>
      <div class="appcontainer">
          <div id="controlspanel">
              <button class="ui" onclick="onBack()">Go back</button>
              <button class="ui" onclick="onSave()">Save</button>
          </div>
      </div>
    </body>
  </html>
  ```

  Тук с вижда част от HTML кода на страницата за създаване на кодовия граф. Имаме тялото на страницата която в себе си има контейнера на контролния панел и двата бутона заедно с техните функции, които ще се извикат, ако бъдат натиснати.

- CSS - език за описание на стилове, използва се основно за описване на представянето на документ, написан на език за маркиране. Най-често се използва заедно с HTML, но може да се приложи върху произволен XML документ. CSS е създаден с цел да бъдат разделени съдържанието и структурата на уеб страниците отделно от тяхното визуално представяне. Преди стандартите за CSS, съдържанието на сайтовете и стила на техния дизайн са писани в една и съща HTML страницата. В резултат на това HTML кодът се превръща в сложен и нечетлив, а всяка промяна в проекта на даден сайт изисквала корекцията да бъде нанасяна в целия сайт страница по страница. Използвайки CSS, настройките за форматиране могат да бъдат поставени в един-единствен файл и тогава промяната ще бъде отразена едновременно на всички страници, които използват този CSS файл.

  ```
  button:hover {
      transform: scale(0.98);
  }
  ```

  Тук виждаме малък пример от стилът на проекта. Чрез него се задава всички бутони да бъдат скалирани когато са посочени с мишката.

- Javascript - често съкращаван JS, е програмен език основна част от WWW технологиите, заедно с HTML и CSS. Над 97% от сайтовете в световен мащаб използват JS за да имплементират интерактивност. Всички големи уеб браузъри имат собствени JavaScirpt интерпретатори (engines) която единствена цел е да интерпретират кода в клиентския браузър. JavaScript е език който имплементира ECMAScript стандарта. Той е динамично типизиран, обектно ориентиран с първи клас функции. Той поддържа и няколко парадигми - движен от събития, функционален и императивен. Има API за работа с текст, дати, регулярни изрази, стандартни структури от данни и DOM. Javascript двигателите оригинално са използвани само в уеб браузърите, но вече са основни компоненти и на някои сървър и техните апликации - например node.js.

  ```
  function onBack() {
    onSave();
    document.location.href = "/";
  }
  ```

  Тук виждаме малка JavaScript функция, част от кода на проекта. Тя извиква друга javascript функция след което променя линка на уеб страницата.

Освен основните уеб технологии, проектът разчита и на два библиотеки.
Едната се използва за да се визуализират възлите в редактора на код, това e baklava JS. Това е редактор на граф и възлите му за уеб браузер. Тя предоставя лесен за употреба редактор на графи и лесен начин за създаване на персонализирани възли. За създаването му е използван тайп скрипт (typescript).

Резултатната страница използва vue.js. Това е модерна библиотека за разработване на интерактивни уеб приложения. Основната цел на Vue.js е да предоставя реактивен дейта байндинг (data binding) и възможност за композиране и преизползване на компоненти. В текущата разработка се използва, за да се улесни опресняването на видимият от потребителя HTML, когато генерирания javascript промени някоя променлива.

## Сървърна част

За сървърната част избрах [Go](https://go.dev/). Това е сравнително модерен език, той има едва тринадесетгодишна история, за справка повечето разпространени езици са от миналия век. Go е статично типизиран, компилиращ се език с автоматично освобождаване на ресурсите (garbage-collected), което дори може да се изключва. Синтаксиса му е близък до този на C с някои изключения. Обектно ориентиран е, но няма класове. Според създателите на Go, целта за създаването му е била породена от появата на многоядрени процесори, паралелни изчисления и ускоряването на работата на компютрите. Google го използват за няколко техни проекти, както и за сайта на езика. Много паралелни процеси позволяват много паралелни сесии едновременно. Въпреки че езикът е с автоматично освобождаване на ресурсите предоставя много добра производителност. Също така предоставя мениджър на пакетите което много улеснява работата. В този проект се използват редица стандартни пакети за json, http server, тестване и други. Също така се използва и външен пакет за работа с web sockets - [Gorilla WebSocket](https://github.com/gorilla/websocket).

# Ръководство за употреба и освновни примери

За да се създаде нова страница обикновенно се добавят нови бутони и текст в началната страница, след което в редактора за код те могат да се използват. Цялата логика на програмата се създава в редактора на код под формата на граф, създаден от възли описани по-надолу и връзки между тях.

## Работа с начална страница

![First example](/documentation/images/homepage.png)

Началната страница има 3 основи компонента:

1. Контролен панел - от него могат да се извършват основните операции както следва:
   * Code editor - отваря страницата за редактора на код
   * View the result - Отваря само резултатния сайт в нова страница.
   * CSS (Styling) - Включва и изключва стилът на сайтът. Когато е изключен създаденият CSS файл е празен.
   * Canvas (Drawing) - Когато е включен, резултатния сайт съдържа и платно в което може да се рисува чрез възли в редактора на код.
   * Падащо меню с предварително създадените [примери](#основни-примери), то съдържа седем примера, няколко основни и два по-сложни.
   * Load example - с този бутон се зарежда примерът избран от горното меню.
   * Add button - Добавя бутон в новосъздадения сайт. След натискане се показват 2 полета за попълване, съответно - текст на бутона и уникален идентификатор. Идентификаторът се ползва в редактора на код, за да може да се изпълнява логика при натискането му.
   * Add header - Добавя текстово поле в новосъздадения сайт. След натискане на бутона се появява поле за попълване на новият текст.
2. Списък от всички създадени елементи в изходната страница - тази част съдържа списък от всички създадени бутони и текстови полета. Също така всеки елемент има бутон за премахване (изтриване) и са посочени всичките идентификатори на бутоните.
3. Резултатен сайт - той е показан в реално време и се обновява след всяка промяна. 

## Работа с редактора на код

![First example](/documentation/images/codingpage.png)

Страницата с редактора на кода има четири основни компонента:

1. Контролен панел - от него може да се записва текущото състояние на редактора Save и потребителя да се връща обратно към основната страница - Go Back.
2. Редактора на кодовата схема - тук потребителя може да създава нови възли (методи), връзки между тях и др. Тук си заслужава да споменем другите две маркирани части.
3. Меню за създаване на нови възли - наричани още методи. Появява се след натискане на десен бутон в редактора. Различните видове възли ще разгледаме [по-напред в тази глава](#основните-видове-възли-методи-в-код-графът-и-техните-параметри).
4. Така изглежда вече създаден пример от 4 възли и връзки м/у тях.

## Основните видове възли-методи в код-графът и техните параметри

Всеки възел (метод) в графа е отговорен за различна функционалност - например има метод отговорен за записване на число в променлива. Възлите имат 3 различна вида свойства:
1. Параметри - това е най-простият вид, от тях и към тях не може да има връзки, те служат единствено за описване на възела. Например името на променлива при записване на такава.
2. Входни параметри - Това са параметри които приемат връзки от други възли, понякога може освен входни параметри да са и прости параметри. Например стойностите при събиране на числа.
3. Изходни параметри - Това са параметри от които могат да излизат връзки. Например резултат или ход на програмата.

За да може да се свържат 2 параметъра единият трябва да е изходен а другия входен, освен това трябва да имат еднакъв тип - отбелязан с цвят в редактора. Към момента има три различни вида връзки, по тях "протичат": числа, булеви стойност или ход на програмата (flow).

### Методи за работа с потока (хода) на кода

Този тип възли са отговорни за хода на програмата. От тях започва изпълнението на всеки фрагмент в графа. Също така потокът на кода се направлява от тях, например с Условие и цикъл.
![First example](/documentation/images/flownodes.png)
Номера от картинката съответсва на номера от списъка, както и името на възела.

1. При започване (On start) - Този метод стартира изпълнението на кода когато резултатната страница се зареди. Той има един единствен параметър и той е изходния поток на кода, т.е. този възел се използва единствено за да извика други възли от графа. Неговата цел е потребителя да има възможността да зададе начални стойности на неговите променливи, те се създават със стойност нула.
2. При времеви интервал (On timer) - Подобно на "On start" този метод стартира изпълнението, но за разлика от него това се случва през определен интервал от време. Освен очакваният изходен параметър за поток на кода, този възел има още един параметър и това е времето през което ще се изпълнява метода в милисекунди. Неговото основно предназначение е да се обновява нещо в изходната страница на определен интервал от време.
3. При клик на бутон (On click) - Този метод се използва като свързочно звено между изходната страница и изходния код. Той отново има изходен параметър за поток на кода, но освен него има и входен параметър - идентификатор на бутон. В това поле се попълва уникален идентификатор на бутон от създадената страница. Всеки път когато този бутон бъде натиснат от потребителя, този метод ще стартира изпълнението на кода свързан към него.
4. При клик на платното за чертаене (On Canvas click) - Този метод е почти идентичен с On Click но за разлика от него е отговорен за кликането в/у платното (ако има такова). Освен обичайният за стартиращите методи изходен параметър - ход на кода, той има още два изходни параметъра от тип число. Те служат за да може да се извлекат координатите в платното (canvas) където потребителя е кликнал, единият дава Х координатата на позицията на мишката, а другия У координатата. Използването на този възел е демонстрирано много добре в примерът "OnClick Velocity".
5. Разделяна на потока (Split flow) - Този метод се използва за да може от един входен поток потребителя да може да изпълни два други метода. Той има един единствен входен параметърът от тип поток на кода и два изходни параметъра от тип поток на кода. Основното предназначение е да може от един метод да се извикат два други метода (подобно на разклонител).
6. Условие (If/Else) - Този възел имплементира основополагащата в програмирането идея за условоност. Т.е. потока на кода кода може да се разклони според дадени условия. Той има два входни и два изходни параметъра, входните са условия, от булев тип и поток, а изходните са поток на кода, ако условието е истина и поток на кода, ако е лъжа. Този метод позволява даден сегменти от кода да се изпълват само ако дадено условие е истина.
7. For цикъл (For loop) - Този възел позволява сегмент от кода да се изпълни няколко пъти без да се налага да се копира йерархията от възли. Подобно на условния метод и този има два входни параметри, входен поток на кода и условие. Изходните параметри са 2 потока на кода, единият (initialization) се изпълнява винаги един път, а след това докато условието входен параметър е истина се изпълнява вторият (Loop flow). Този метод се използва когато даден сегмент от кода трябва да се изпълни няколко пъти подред (в цикъл). Първият изходен параметър се използва за инициализация на стойностите на променливите, които ще бъдат използвани по време на цикличността, той се извиква само един път в началото. След това се извиква вторият изходен път докато условието е истина, ако то никога не е истина, не се извиква дори и един път.    

### Методи за работа с числа

Тези методи са отговорни за всички операции свързани с числа, както и за четене и записване на променливи.
![First example](/documentation/images/numnodes.png)
Номера от картинката съответсва на номера от списъка, както и името на възела.

1. Четене на число (Read num) - Този метод позволява да се прочете числова стойност от променлива. Той има два параметъра, име на променливата и стойност. Когато стойността бъде поискана от друг метод който ще я използва, се прочита променливата с подаденото име и се връща нейната стойност. Ако една променлива бива спомената само в "четене на число", т.е. не се записва стойност в нея никога, връщаният резултат винаги е 0.
2. Писане на число (Write num) - Чрез този метод записваме числова стойност в променлива. Той има три параметъра - входен поток на кода, име на променливата и стойност на променливата. Когато чрез входния поток този метод бъде извикан, той започва да оценява подграфът който е вързан към стойността на променливата. След това получената стойност се записва в променлива с посоченото име, имайте предвид че променливите не се декларират експлицитно, след първото им срещане в какъвто и да е възел, те вече са напълно функционални.
3. Случайно число (Random num) - Този възел може да генерира случайно число в интервал. Той има два входни - миниум и максимум и 1 един изходен параметър - резултат. Когато се поиска стойност от тзи метод той оценява минимума и максимум и връща случайно число в този интервал [min, max). След това получения резултат се предава през изходния параметър на следващия възел.
4. Модул на число (Absolute num) - Този метод връщат резултат абсолютна стойност на подадения параметър. Той има два параметъра - входно число и резултат. Когато резултатът е необходим на друг възел от графа този нод се извиква и се оценява неговия входен параметър, след това през резултатния параметър се подова абсолютната стойност на оценения под граф.
5. Синус (Sinus) - Връща синус от подадения ъгъл. Има два параметъра - входен ъгъл и резултат. Ъгълът се подава в градуси (не в радиани). За да се изчисли резултатът се оценява входния параметър, след което се изчислява синус от полученото число и се подава през резултатния аргумент.
6. Косинус (Cosinus) - Връща косинус от подадения ъгъл. Има два параметъра - входен ъгъл и резултат. Както и в предходния метод Ъгълът се подава в градуси (не в радиани). За да се изчисли резултатът се оценява входния параметър, след което се изчислява косинус от полученото число и се подава през резултатния аргумент.
7. Числови оператори (Operators) - Този метод позволява да се извършват основните числови операции - събиране, изваждане, умножение, деление и целочислено деление с модул. Той има четири параметъра, два входни за двата операнда на операцията - А и Б, един за вида на операцията и последния е резултатът от операцията. Този възел е доста интуитивен, когато се поиска неговото оценяване се оценяват двата му аргумента - А и Б, след което се извършва избраната от падащото меню на възела операция, тя се извършва върву вече оценените операнди и резултата се предава по графът. Този възел поддържа само два операнда, ако искате да съберете три числа е необходимо с един такъв възел да съберете първите две числа и след това резултатът от този възел да го съберете с третото число. С този подход може да композирате много операнди. Важно е да се спомене, че към момента няма защита от деление на 0 и в тези случаи резултатната програма няма да работи правилно.
8. Сравняване на числа (Compare num) - Този тип възел позволява базови сравнения между 2 числа. Той има 4 параметъра, отново два операнда - А и Б, тип на операцията и резултат, който е от булев тип (истина или лъжа). При поискване за оценяване на възела, 2та операнда се оценяват след което се сравняват с операцията избрана от падащото меню и резултат, който е истина или лъжа, се предава през резултатния параметър. Има 6 вида операции:
     - Equal(==) - Ако А и Б са равни връща истина, в противен случай резултата е лъжа.
     - Not Equal(!=) - Ако А и Б са различни връща лъжа, ако ли не връща истина.
     - Greater Than(>) - Проверява дали А е по-голямо от Б и връща истина ако е, в противен случай лъжа.
     - Less Than(<) - Проверява дали А е по-малко от Б и връща истина.
     - Greater or Equal(>=) - Проверява дали А е по-голямо или равно на Б и връща истина ако е.
     - Less or Equal(<=) - Проверява дали А е по-малко или равно на Б и връща истина ако е и лъжа в противен случай.

### Методи за работа с масиви

Тези методи отговарят за всички основни операции с числови масиви. Четене на размер, четене на елемент, добавяне на елемент и други.
![First example](/documentation/images/arraynodes.png)
Номера от картинката съответсва на номера от списъка, както и името на възела.

1. Инициализация на масив (Init array) - Този метод позволява да се инициалзира масив с числа, с други думи да се зададът начални числови стойности. Той има три параметъра, име на масива, нови стойности на масива и входен поток за кода - който предизвиква изпълнението на този възел. Стойността която ще се използва за инициализиране на масива трябва да бъде числа разделени със запетайки, например "3, 2, 1.5". Този метод е еквивалентен на редица извиквания на "Добавяне на число накрая" (Push back num). 
2. Четене на големината на масив (Read array size) - Този метод позволява да се прочете размера на един числов масив - броя елементи в него. Той има два параметъра име на масива и резултат. Когато се поиска от възела да се оцени той прочита името на променливата, взима размера на масива с това име и го предава през резултатния параметър. Той често бива използван в комбинация със сравнение на числа (Compare num) и цикъл (for loop) за да се обходят всичките елементи на един масив. Важно е да се отбележи че ако подаденото име не отговаря на име на масив, то резултатът е недефиниран.
3. Четена на число от масив (Read array num) - Този възел се използва за да се прочете дадено число от масив. Той има три параметъра, име на масива, индекс на числото и резултат. Както във всички програмни езици така и тук индексирането започва от нула. Т.е. първият елемент е с индекс 0, вторият е с индекс 1 и т.н. Когато резултатът се поиска от друг възел от графа, този метод оценява входната връзка за индекс, след което от дадения масив се взима елемента с ново-оценения индекс и се подава на резултатния параметър. Важно е да се отбележи, че ако масивът има по-малко елементи от подадения индекс, то резултатът е недефиниран.
4. Добавяне на число накрая (Push back num) - Този възел позволява да се добави нова стойност в масива на последна позиция, т.е. добавя се един елемент в края на масива. Той има три параметъра, входен поток на кода, име на масива и числова стойност която трябва да се добави. Когато потока на кода извика този метод, се оценява стойността на входното число, добавя се нов елемент в края на масива и оценената стойност се записва в него.
5. Писане на число в масив (Write array num) - Този метод е реципрочен на четенето на число в масив, той позволява на даден индекс в масив, ако съществува, да се запише число. Този метод има 4 параметъра, за приемане на потока на код, за стойност която да се запише в масива, за индекс на който да се запише стойността и име на масива. Когато потокът на код "извика" този възел той оценява параметъра за индекс и на дадения индекс в масива записва оценката на параметъра за стойност.  Както и в четенето на число в масив, така и тук, е важно да се спомене, че ако индексът е извън границите на масива, резултатът от тази операция е недефиниран.

### Методи за рисуване в платно (canvas)

Тези методи отговарят за всички основни операции с платното за рисуване (canvas). За да работят коректно трябва да има добавен платно в резултатния сайт. Когато има добавено платно (canvas) в страницата, в редактора на код могат да се използват две нови променливи - CANVAS_W и CANVAS_H, който са съответно широчина и височина (canvas width, canvas height) на платното за рисуване. Всички методи по-долу позволяват да се рисува и извън платното, но само частта от фигурата която е в платното ще бъде видима.
![First example](/documentation/images/canvasnodes.png)
Номера от картинката съответсва на номера от списъка, както и името на възела.

1. Рисуване на правоъгълник (Draw rectangle) - Този възел позволява да се изрисува правоъгълник в даден цвят в платното за рисуване. Той има 6 параметъра, всичките входни, входен поток на кода, цвят на правоъгълника, точка от която да започне - тя се състой от два числови параметъра за Х и У координтаи, дължина на правоъгълника и ширина. Страните на правоъгълника са успоредни на страните на платното за рисуване. Целият правоъгълник се оцветява в избраният цвят. Ако върху него се изрисуват други фигури той не се променя, въпреки че се наслагват.
2. Рисуване на линия (Draw line) - Този метод изрисува линия в платното. Той има шест параметъра, входен поток на кода, цвят на линията, точка от която започва и точка в която свършва, като всяка от последните две е създадена от два входни числова параметъра за Х координата и У координата. След извикване от потока на кода се оценяват всички входни параметри и се изрисува права линия от стартовата точка до финалната такава. Както и при другите фигури ако върху линията се изрисуват други фигури това не я променя или премахва. 
3. Рисуване на кръг (Draw circle) - Този метод изрисува кръг в платното. Той има пет параметъра, вход за поток на кода, цвят, център, който отново е описан от два числови параметъра за координати и радиус. Изрисува се кръг с дадения център и радиус, той не е защрихован. След като потокът на кода предаде управлението на този възел, той оценява всичките си параметри и изрисува кръга.
4. Изчистване на правоъгълник (Clear rectangle) - Този метод служи за изчистване на част от платното. По същество той е абсолютно еднакъв с Рисуване на правоъгълник (Draw rectangle), но вместо да приема цвят той автоматично използва основния цвят на платното, който във момента може да бъде само бял.

## Основни примери

Проектът предлага няколко готови приложения. Тяхната основна цел е да демонстрират възможностите на проекта, както и основните конструкции, които може да бъдат прилагани от потребителя.

### 1. Samples

![Samples](/documentation/images/example1.png)

Този пример съдържа в себе си четири под примера. Нека разгледаме бегло всеки един тях:
1. Инкрементиране на число с бутон. Това е най-лесният пример, той показва как да извършим действие след натискане на бутон, как да прочетем и запишем променлива, както и как да съберем едно число и единица. Когато се натисне бутона в страницата възелът On click започва изпълнението на под графа. Тогава той извиква записването на променливата, когато променливата се записва се оценяват аргументите ѝ. Първият аргумент е събиране на числа, като едното число е посочено и е единица, другият се оценява, тогава се оценява възела за четене на променлива.
2. Този пример много прилича на първия, но вместо събиране на число с променлива, се генерира ново случайно число. Потокът на кода и начина на оценява на възлите е напълно идентичен с първия пример.
3. Последните два примера са идентични с първия пример, но вместо след натискане на бутон от потребителя, да се увеличи променливата, тя се увеличава на определен времеви интервал. Т.е. тук инициаторът на изпълнение не е потребителя, ами таймер.   

### 2. Simple game

![Simple game](/documentation/images/example2.png)

Тук е разработена минималистична игра. Целта е играча да печели максимално количество от игровата валута - пари. За целта потребителя може да натиска бутон с който работи и печели пари, да се обучава срещу определена цена, което увеличава спечелените пари в последствие. Също така може да си купува работници, които генерират пари всяка секунда. Този пример има доста по-сложен граф на кода, но новостта спрямо [предходния пример](#1-samples) е възел от тип "Условие" (If/Else). На фокусираната част от графа виждаме пет възела, които формират нововъдението. Когато потребителя на играта натисне бутона с идентификатор ID2, се предава контрола върху If/Else възелът. В този случай ако условието е истина, потока на кода предава контрола напред, ако е лъжа, изпълнението на този клон от графа приключва до повторно натискане на бутона. Когато контролът е попаднал в If/Else възела той оценява неговите зависимости (входни параметри), в този случай една единствена от булев тип. За да бъде оценена променливата от булев тип контролът попада във възелът за сравнение, а той от своя страна оценява свойте зависимости. В крайна сметка се сравнява дали MONEY е по-голямо или равно на UP. Ако е по-голямо контролът продължава натам, ако не е изпълнението започнало от този бутон се прекратява, тъй като няма връзка излизаща от False параметъра на възела.

### 3. Draw random squares

![Draw random squares](/documentation/images/example3.png)

Минималистичен пример, на който единствената цел е да покаже как се рисува правоъгълник с метода Draw rectangle и как се изчиства платното за рисуване с метода Clear rectangle. Всеки път когато потребителя натисне бутона за рисуване на квадрат се генерират две случйани числа и се рисува квадрат с горен десен ъгъл полученият координат. Също така този пример показва как в кодът на графът да използваме размерите на платното за рисуване. Благодарението на това единственото правило което следва генератора е да не се изрисува квадрат извън платното.

### 4. Velocity square

![Velocity square](/documentation/images/example4.png)

Този пример демонстрира основополагащ пример в компютърната графика, как се изрисуват движещи си предмети. Тук се демонстрира как се изрисува движещ се квадрат, а именно на всеки кадър се изчиства цялото платно и се изрисува новата позиция на квадрата. Също така новостта тук е как се смята новата позиция на обекта. Също така се демонстира как се смята скороста, т.е. изместването, на движещи обекти. Приомът е широко разпостранен в компютърната графика. Както и всичко друго в канваса, така и този квадрат има координати, неговата скорост я изразяваме чрез вектор (Х, Y), където Х е скороста по Х и У по оста У. След това на всеки кадър текущата позиция се събира с вектора на скороста и така получаваме новата позиция. Също така този пример демонстрира много елегантно нуждата от "При времеви интервал (On timer)" възела, той се използва за да се извършат всичките изчисления на всеки кадър. Иначе казано на всеки 33 милисекунди благодарение на него, платното се изчиства, пресмята се новата позиция на квадрата спрямо скоростта зададена от потребителя и за финал се изрисува квадрата на новата му позиция.


### 5. OnClick velocity

![OnClick velocity](/documentation/images/example5.png)

Този пример надгражда предния като демонстрира как потребителя може взаимодейства с платното за рисуване, освен това показва изрисуването на линия и кръг. Основната задача на този пример е да демонстрира как потребителя може да взаимодейства с платното за рисуване. Когато потребителя, натисне върху платното, позиция на мишката се записва. След това на тази позиция се изрисува кръг, както и се изрисува линия между текущата позиция на квадрата и туко що създадената от потребителя. Също така този пример показва как да се пресметне скороста необходима на квадрата за да достигне до "кръгчето" за 50 кадра. Това става много просто, първо се смята отместването на квадрата от целта, т.е. изваждане на вектори, и след това се разделя на необходимия брой кадри за да се постигне желаната скорост.

### 6. Particles

![Particles](/documentation/images/example6.png)

Тук отново се надраждат предходните примери, като този път се добавят масивите и с тях идва възможността да се изрисуват редица движещи се обекти. Тук освновната задача е съвкупност от примери четири и пет, когато потребителя кликне върху платното за рисуване той създава нов елемент в него. Тези елементи автоматичнои придобиват случайна скорост и посока и започват да се движат в нея. Това се постига чрез масиви, всяка частица си има собствена позиция и посока. Тя бива прерисувана на всеки кадър както в пример четири. Оснвонвата цел на пример е да демонстрира колко елегантно се решава тази задача с масиви.

### 7. 3D Cube

![3D Cube](/documentation/images/example7.png)

Това е финалният пример, който е и най-сложен. Той демонстрира как, със системата реализирана в тази дипломна работа, могат да се създадът примери за: ротация в 3д пространстовото и проекция на триизмерен куб в двуизмерно пространство - платното за рисуване. Примера изпозлва всички техники показани в предните, описан е всеки връх на куба в масив за всяка координата, след това и всяко ребро от куба е описано, отново с помощта на масиви. С помощта на предоставените възли/методи е имплементира ротация както и параметризирана проекция.
# Заключение

Разбира се има много възможности за развитие и подобрение, тук ще спомена някои от тях:
- Би могла да се имплементира верификация на програмния граф. Т.е. да се проверява за неизпълними пътища, безкрайни цикли, възможни двусмислия и други.
- Могат да се реализират още много възли в програмния граф - работа със стрингове, логически операции, връзка със сървър и много други.
- Много добро подобрение би било възможността да се добавят класове от потребителя, т.е. групирани възли и променливи които описват даден обект.

Вепреки безкрайните възможности за развитие на решението, поставената задача беше реализирана успешно. Потребителят може да създава от лесно до средно сложни приложения без никакви знания по програмиране, което бе и целта. 

# Източници

- [Wikipedia flow based programing](https://en.wikipedia.org/wiki/Flow-based_programming)
- https://wikipedia.org/wiki/HTML
- https://wikipedia.org/wiki/CSS
- https://wikipedia.org/wiki/JavaScript
- https://en.wikipedia.org/wiki/Go_(programming_language)
- https://wikipedia.org/wiki/Algorithm
- https://github.com/newcat/baklavajs
- https://vuejs.org/


